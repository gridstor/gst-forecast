// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["public", "Forecasts"]
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model caiso_long_term_forecasts_annual {
  FlowDateStart                BigInt?
  Term                         String?
  MarkDate                     String?
  MarkType                     String?
  MarkCase                     String?
  MarkFundamentalsDesc         String?
  MarkModelTypeDesc            String?
  MarkDispatchOptimizationDesc String?
  GridStorPurpose              String?
  Value                        Float?
  Units                        String?
  TableCreationTime            String?
  MarkLocation                 String?
  MarkMarket                   String?
  CurveCreator                 String?
  CurrentMark                  BigInt?
  valueType                    String?

  @@ignore
  @@schema("public")
}

model curve_definitions {
  curve_id                        Int               @id @default(autoincrement())
  mark_type                       String?           @db.VarChar
  mark_case                       String?           @db.VarChar
  mark_date                       DateTime?         @db.Timestamp(6)
  location                        String?           @db.VarChar
  market                          String?           @db.VarChar
  curve_creator                   String?           @db.VarChar
  mark_fundamentals_desc          String?           @db.VarChar
  mark_model_type_desc            String?           @db.VarChar
  mark_dispatch_optimization_desc String?           @db.VarChar
  gridstor_purpose                String?           @db.VarChar
  value_type                      String?           @db.VarChar
  created_at                      DateTime?         @default(now()) @db.Timestamp(6)
  curve_start_date                DateTime?         @db.Timestamp(6)
  curve_end_date                  DateTime?         @db.Timestamp(6)
  granularity                     String?           @db.VarChar
  display_curves                  display_curves[]
  price_forecasts                 price_forecasts[]

  @@index([curve_start_date, curve_end_date], map: "idx_curve_dates")
  @@index([location], map: "idx_curve_location")
  @@index([mark_case], map: "idx_curve_mark_case")
  @@index([mark_date], map: "idx_curve_mark_date")
  @@index([mark_type], map: "idx_curve_mark_type")
  @@index([market], map: "idx_curve_market")
  @@index([market, location], map: "idx_curve_market_location")
  @@schema("public")
}

model display_curves {
  display_id        Int
  curve_id          Int
  display_order     Int?
  display_color     String?           @db.VarChar(50)
  display_label     String?           @db.VarChar(100)
  created_at        DateTime?         @default(now()) @db.Timestamp(6)
  curve_definitions curve_definitions @relation(fields: [curve_id], references: [curve_id], onDelete: NoAction, onUpdate: NoAction)
  website_displays  website_displays  @relation(fields: [display_id], references: [display_id], onDelete: NoAction, onUpdate: NoAction)

  @@id([display_id, curve_id])
  @@index([curve_id], map: "idx_display_curves_curve_id")
  @@index([display_id], map: "idx_display_curves_display_id")
  @@schema("public")
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
model ercot_long_term_forecasts_annual {
  FlowDateStart                BigInt?
  Term                         String?
  MarkDate                     String?
  MarkType                     String?
  MarkCase                     String?
  MarkFundamentalsDesc         String?
  MarkModelTypeDesc            String?
  MarkDispatchOptimizationDesc String?
  GridStorPurpose              String?
  Value                        Float?
  Units                        String?
  TableCreationTime            String?
  MarkLocation                 String?
  MarkMarket                   String?
  CurveCreator                 String?
  CurrentMark                  BigInt?
  valueType                    String?

  @@ignore
  @@schema("public")
}

model price_forecasts {
  id                Int                         @id @default(autoincrement())
  curve_id          Int?
  flow_date_start   DateTime?                   @db.Timestamp(6)
  granularity       Unsupported("granularity")?
  value             Float?
  units             String?                     @db.VarChar
  location          String?                     @db.VarChar
  mark_case         String?                     @db.VarChar
  curve_creator     String?                     @db.VarChar
  value_type        String?                     @db.VarChar
  mark_date         DateTime?                   @db.Timestamp(6)
  curve_definitions curve_definitions?          @relation(fields: [curve_id], references: [curve_id], onDelete: NoAction, onUpdate: NoAction)

  @@index([curve_creator], map: "idx_price_creator")
  @@index([curve_id, flow_date_start], map: "idx_price_curve_date")
  @@index([curve_id], map: "idx_price_curve_id")
  @@index([flow_date_start], map: "idx_price_flow_date")
  @@index([location], map: "idx_price_location")
  @@index([mark_case], map: "idx_price_mark_case")
  @@index([mark_date], map: "idx_price_mark_date")
  @@index([value_type], map: "idx_price_value_type")
  @@schema("public")
}

model website_display {
  display_id   Int       @id @default(autoincrement())
  display_name String    @db.VarChar
  description  String?   @db.VarChar
  created_at   DateTime? @default(now()) @db.Timestamp(6)
  updated_at   DateTime? @default(now()) @db.Timestamp(6)

  @@schema("public")
}

model website_displays {
  display_id     Int              @id @default(autoincrement())
  display_name   String           @unique @db.VarChar(100)
  description    String?          @db.VarChar
  created_at     DateTime?        @default(now()) @db.Timestamp(6)
  updated_at     DateTime?        @default(now()) @db.Timestamp(6)
  display_curves display_curves[]

  @@schema("public")
}

// ========== ENUMS ==========

enum InstanceStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  ACTIVE
  SUPERSEDED
  EXPIRED
  FAILED

  @@schema("Forecasts")
}

enum RunType {
  SCHEDULED
  MANUAL
  TRIGGERED
  BACKFILL
  CORRECTION

  @@schema("Forecasts")
}

enum InputType {
  WEATHER_FORECAST
  WEATHER_ACTUAL
  DEMAND_FORECAST
  DEMAND_ACTUAL
  GENERATION_FORECAST
  GENERATION_ACTUAL
  TRANSMISSION_LIMITS
  FUEL_PRICES
  HYDRO_CONDITIONS
  RENEWABLE_FORECAST
  MARKET_FUNDAMENTALS
  REGULATORY_CHANGES
  LEGACY_MIGRATION
  OTHER

  @@schema("Forecasts")
}

enum UsageType {
  PRIMARY
  VALIDATION
  REFERENCE
  FALLBACK

  @@schema("Forecasts")
}

enum CurveType {
  REVENUE
  REVENUE_OTHER
  ENERGY
  ENERGY_ARB
  AS
  TB2
  TB4
  RA
  DA
  RT
  OTHER

  @@schema("Forecasts")
}

enum BatteryDuration {
  TWO_H           @map("2H")
  TWO_POINT_SIX_H @map("2.6H")
  FOUR_H          @map("4H")
  EIGHT_H         @map("8H")
  UNKNOWN
  OTHER

  @@schema("Forecasts")
}

enum ScenarioType {
  BASE
  LOW
  HIGH
  P50
  P90
  P10
  DOWNSIDE
  UPSIDE
  WORST
  BEST
  ACTUAL
  TARGET
  LOWER_BOUND
  UPPER_BOUND
  OTHER

  @@schema("Forecasts")
}

enum DegradationType {
  NONE
  YEAR_1
  YEAR_2
  YEAR_5
  YEAR_10
  YEAR_15
  YEAR_20
  CUSTOM
  OTHER

  @@schema("Forecasts")
}

enum ScheduleType {
  REGULAR
  AD_HOC
  TRIGGERED
  EVENT_BASED

  @@schema("Forecasts")
}

enum UpdateFrequency {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  ANNUALLY
  ON_DEMAND

  @@schema("Forecasts")
}

enum RunStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  PARTIAL

  @@schema("Forecasts")
}

enum ChangeType {
  INITIAL
  UPDATE
  CORRECTION
  REVISION
  FINAL
  ROLLBACK

  @@schema("Forecasts")
}

// ========== MODELS ==========

model CurveDefinition {
  id              Int             @id @default(autoincrement())
  curveName       String          @unique @db.VarChar(255)
  market          String          @db.VarChar(50)
  location        String          @db.VarChar(100)
  // product REMOVED - too specific for a general definition
  // curveType MOVED TO CurveInstance - allows multiple types per definition
  // commodity MOVED TO CurveInstance - allows multiple commodities per definition
  // granularity MOVED TO CurveInstance - allows different granularities per instance
  // scenario MOVED TO CurveInstance - allows different scenarios per instance
  // degradationType MOVED TO CurveInstance - allows different degradation per instance
  batteryDuration String          @default("UNKNOWN") @db.VarChar(50)
  units           String          @default("$/MWh") @db.VarChar(50)
  timezone        String          @default("UTC") @db.VarChar(50)
  description     String?         @db.Text
  isActive        Boolean         @default(true)
  metadata        Json?           @db.JsonB
  createdAt       DateTime        @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime        @default(now()) @updatedAt @db.Timestamptz(6)
  createdBy       String?         @db.VarChar(100)

  // Relations
  instances     CurveInstance[]
  schedules     CurveSchedule[]
  defaultInputs DefaultCurveInput[]

  @@index([market, location])
  @@index([batteryDuration])
  @@index([isActive])
  @@index([createdAt])
  @@schema("Forecasts")
}

model CurveInstance {
  id                  Int            @id @default(autoincrement())
  curveDefinitionId   Int
  instanceVersion     String         @db.VarChar(50)
  // MOVED FROM CurveDefinition - allows maximum flexibility per instance
  curveType           String?        @db.VarChar(100)  // e.g., "Revenue Forecast", "Price Forecast"
  commodity           String?        @db.VarChar(50)   // e.g., "Total Revenue", "EA Revenue", "AS Revenue"
  granularity         String?        @db.VarChar(20)   // e.g., "MONTHLY", "QUARTERLY", "ANNUAL"
  scenario            String?        @db.VarChar(100)  // e.g., "BASE", "HIGH", "LOW"
  degradationType     String?        @db.VarChar(100)  // e.g., "NONE", "YEAR_1", "YEAR_5"
  deliveryPeriodStart DateTime       @db.Timestamptz(6)
  deliveryPeriodEnd   DateTime       @db.Timestamptz(6)
  forecastRunDate     DateTime       @db.Timestamptz(6)
  freshnessStartDate  DateTime       @db.Timestamptz(6)
  freshnessEndDate    DateTime?      @db.Timestamptz(6)
  status              InstanceStatus @default(DRAFT)
  modelType           String?        @db.VarChar(100)
  modelVersion        String?        @db.VarChar(50)
  runType             RunType        @default(MANUAL)
  createdBy           String         @db.VarChar(100)
  approvedBy          String?        @db.VarChar(100)
  approvedAt          DateTime?      @db.Timestamptz(6)
  notes               String?        @db.Text
  metadata            Json?          @db.JsonB
  createdAt           DateTime       @default(now()) @db.Timestamptz(6)
  updatedAt           DateTime       @default(now()) @updatedAt @db.Timestamptz(6)

  // Relations
  curveDefinition  CurveDefinition     @relation(fields: [curveDefinitionId], references: [id])
  priceForecasts   PriceForecast[]
  curveData        CurveData[]
  inputLineage     CurveInputLineage[]
  versionHistory   VersionHistory[]    @relation("CurrentInstance")
  previousVersions VersionHistory[]    @relation("PreviousInstance")
  qualityMetrics   QualityMetric[]

  @@unique([curveDefinitionId, instanceVersion])
  @@index([curveDefinitionId])
  @@index([status])
  @@index([curveType, commodity])
  @@index([granularity, scenario])  // NEW: Index for filtering by granularity/scenario
  @@index([freshnessStartDate, freshnessEndDate])
  @@index([deliveryPeriodStart, deliveryPeriodEnd])
  @@index([forecastRunDate])
  @@index([createdAt])  // NEW: Index for sorting by creation time
  @@schema("Forecasts")
}

model PriceForecast {
  id              Int      @id @default(autoincrement())
  curveInstanceId Int
  timestamp       DateTime @db.Timestamptz(6)
  pValue          Int      // The percentile: 5, 25, 50, 75, 95, etc.
  value           Float    // The actual value for this p-value
  flags           String[] @default([])
  createdAt       DateTime @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // Relations
  curveInstance CurveInstance @relation(fields: [curveInstanceId], references: [id], onDelete: Cascade)

  @@unique([curveInstanceId, timestamp, pValue])
  @@index([curveInstanceId])
  @@index([timestamp])
  @@index([pValue])
  @@index([curveInstanceId, timestamp])
  @@schema("Forecasts")
}

model CurveData {
  id              Int      @id @default(autoincrement())
  curveInstanceId Int
  timestamp       DateTime @db.Timestamptz(6)
  // WIDE FORMAT: Pre-pivoted p-value columns
  valueP5         Float?   // P5 percentile value
  valueP25        Float?   // P25 percentile value
  valueP50        Float    @default(0) // P50 percentile value (median, required)
  valueP75        Float?   // P75 percentile value
  valueP95        Float?   // P95 percentile value
  flags           String[] @default([])
  createdAt       DateTime @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // Relations
  curveInstance CurveInstance @relation(fields: [curveInstanceId], references: [id], onDelete: Cascade)

  @@index([curveInstanceId], map: "idx_curvedata_instance")
  @@index([timestamp], map: "idx_curvedata_timestamp")
  @@index([curveInstanceId, timestamp], map: "idx_curvedata_instance_timestamp")
  @@schema("Forecasts")
}

model CurveInputLineage {
  id               Int       @id @default(autoincrement())
  curveInstanceId  Int
  inputType        InputType
  inputSource      String    @db.VarChar(100)
  inputIdentifier  String    @db.VarChar(255)
  inputVersion     String?   @db.VarChar(50)
  inputTimestamp   DateTime  @db.Timestamptz(6)
  usageType        UsageType
  transformApplied String?   @db.Text
  weight           Float?
  metadata         Json?     @db.JsonB
  createdAt        DateTime  @default(now()) @db.Timestamptz(6)

  // Relations
  curveInstance CurveInstance @relation(fields: [curveInstanceId], references: [id], onDelete: Cascade)

  @@index([curveInstanceId])
  @@index([inputType])
  @@index([inputSource])
  @@schema("Forecasts")
}

model VersionHistory {
  id                 Int        @id @default(autoincrement())
  curveInstanceId    Int
  previousInstanceId Int?
  changeType         ChangeType
  changeReason       String     @db.Text
  changedBy          String     @db.VarChar(100)
  changedAt          DateTime   @default(now()) @db.Timestamptz(6)
  changeDetails      Json?      @db.JsonB

  // Relations
  curveInstance    CurveInstance  @relation("CurrentInstance", fields: [curveInstanceId], references: [id])
  previousInstance CurveInstance? @relation("PreviousInstance", fields: [previousInstanceId], references: [id])

  @@index([curveInstanceId])
  @@index([previousInstanceId])
  @@schema("Forecasts")
}

model ScheduleRun {
  id               Int       @id @default(autoincrement())
  scheduleId       Int
  runDate          DateTime  @db.Timestamptz(6)
  runType          RunType   @default(SCHEDULED)
  instancesCreated Int       @default(0)
  status           String    @default("PENDING") @db.VarChar(50)
  startedAt        DateTime? @db.Timestamptz(6)
  completedAt      DateTime? @db.Timestamptz(6)
  metadata         Json?     @db.JsonB

  // Relations
  schedule CurveSchedule @relation(fields: [scheduleId], references: [id])

  @@index([scheduleId])
  @@index([runDate])
  @@index([status])
  @@schema("Forecasts")
}

model QualityMetric {
  id              Int      @id @default(autoincrement())
  curveInstanceId Int
  metricType      String   @db.VarChar(50)
  metricValue     Float
  comparisonType  String?  @db.VarChar(50)
  comparisonId    Int?
  calculatedAt    DateTime @default(now()) @db.Timestamptz(6)
  metadata        Json?    @db.JsonB

  // Relations
  curveInstance CurveInstance @relation(fields: [curveInstanceId], references: [id])

  @@index([curveInstanceId])
  @@index([metricType])
  @@schema("Forecasts")
}

model DefaultCurveInput {
  id                Int       @id @default(autoincrement())
  curveDefinitionId Int
  inputType         InputType
  inputSource       String    @db.VarChar(100)
  inputIdentifier   String    @db.VarChar(255)
  isRequired        Boolean   @default(true)
  defaultWeight     Float?
  validFrom         DateTime  @default(now()) @db.Timestamptz(6)
  validUntil        DateTime? @db.Timestamptz(6)

  // Relations
  curveDefinition CurveDefinition @relation(fields: [curveDefinitionId], references: [id])

  @@index([curveDefinitionId])
  @@schema("Forecasts")
}

model CurveSchedule {
  id                 Int             @id @default(autoincrement())
  curveDefinitionId  Int
  scheduleType       ScheduleType    @default(REGULAR)
  frequency          UpdateFrequency
  dayOfWeek          Int?
  dayOfMonth         Int?
  timeOfDay          DateTime        @default("1970-01-01T09:00:00Z") @db.Time
  leadTimeDays       Int             @default(0)
  freshnessDays      Int             @default(30)
  responsibleTeam    String          @default("Market Analysis") @db.VarChar(100)
  notificationEmails String[]
  importance         Int             @default(3)
  isActive           Boolean         @default(true)
  validFrom          DateTime        @default(now()) @db.Timestamptz(6)
  validUntil         DateTime?       @db.Timestamptz(6)
  metadata           Json?           @db.JsonB
  createdAt          DateTime        @default(now()) @db.Timestamptz(6)
  updatedAt          DateTime        @default(now()) @updatedAt @db.Timestamptz(6)

  // Relations
  curveDefinition   CurveDefinition         @relation(fields: [curveDefinitionId], references: [id])
  scheduleRuns      ScheduleRun[]
  instanceTemplates CurveInstanceTemplate[]

  @@index([curveDefinitionId])
  @@index([isActive, validFrom, validUntil])
  @@index([frequency])
  @@schema("Forecasts")
}

model CurveInstanceTemplate {
  id                    Int      @id @default(autoincrement())
  scheduleId            Int
  deliveryPeriodStart   DateTime @db.Timestamptz(6)
  deliveryPeriodEnd     DateTime @db.Timestamptz(6)
  degradationStartDate  DateTime? @db.Date
  granularity           String   @db.VarChar(50)
  instanceVersion       String   @default("v1") @db.VarChar(50)
  
  // Custom enum values (stored as TEXT when not matching predefined enums)
  customCurveType       String?  @db.VarChar(100)
  customBatteryDuration String?  @db.VarChar(50)
  customScenario        String?  @db.VarChar(100)
  customDegradeType     String?  @db.VarChar(100)
  
  // Metadata
  notes                 String?  @db.Text
  createdAt             DateTime @default(now()) @db.Timestamptz(6)
  updatedAt             DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  createdBy             String?  @db.VarChar(100)
  
  // Relations
  schedule              CurveSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  @@index([scheduleId])
  @@index([deliveryPeriodStart, deliveryPeriodEnd])
  @@schema("Forecasts")
}
